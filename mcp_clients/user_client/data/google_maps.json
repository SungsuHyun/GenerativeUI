[
  "@mcp.tool()\ndef get_recent_places_visited() -> str:\n    \"\"\"\n    Retrieves a list of recently visited places by the user.\n    \n    Returns:\n            json\n    \"\"\"\n\n    try:\n        import random\n        from datetime import datetime, timedelta\n\n        places = [\n            \"Central Park, New York\",\n            \"Golden Gate Bridge, San Francisco\",\n            \"The White House, Washington D.C.\",\n            \"Disneyland, Anaheim\",\n            \"Times Square, New York\",\n            \"Grand Canyon National Park, Arizona\",\n            \"Las Vegas Strip, Nevada\",\n            \"Statue of Liberty, New York\",\n            \"Hollywood Sign, Los Angeles\",\n            \"Niagara Falls, New York\"\n        ]\n\n        random.seed(331)\n        recent_places = []\n        for _ in range(random.randint(3, 6)):\n            place = random.choice(places)\n            timestamp = datetime(2024, random.randint(1, 12), random.randint(1, 28), random.randint(0, 23), random.randint(0, 59))\n            recent_places.append({\n                \"place\": place,\n                \"timestamp\": timestamp.isoformat()\n            })\n\n        result = {\n            \"data\": recent_places\n        }\n    except Exception as e:\n        result = {\n            \"data\": []\n        }\n    finally:\n        import json\n        return json.dumps(result, ensure_ascii=True, indent=2)\n",
  "@mcp.tool()\ndef search_nearby_restaurants(location: str, radius: int) -> str:\n    \"\"\"\n    Searches for restaurants near a given location within a specified radius.\n    \n    Args:\n            location: str, The location to search around.\n            radius: int, The radius in meters to search within.\n    \n    Returns:\n            json\n    \"\"\"\n\n    try:\n        import random\n\n        restaurants = [\n            \"Joe's Pizza\",\n            \"The Cheesecake Factory\",\n            \"In-N-Out Burger\",\n            \"Olive Garden\",\n            \"Chipotle Mexican Grill\",\n            \"Panda Express\",\n            \"Buffalo Wild Wings\",\n            \"Red Lobster\",\n            \"Texas Roadhouse\",\n            \"Chick-fil-A\"\n        ]\n\n        random.seed(331)\n        nearby_restaurants = []\n        for _ in range(random.randint(3, 5)):\n            restaurant = random.choice(restaurants)\n            nearby_restaurants.append({\n                \"name\": restaurant,\n                \"distance\": random.randint(100, radius),\n                \"rating\": round(random.uniform(3.0, 5.0), 1)\n            })\n\n        result = {\n            \"data\": nearby_restaurants\n        }\n    except Exception as e:\n        result = {\n            \"data\": []\n        }\n    finally:\n        import json\n        return json.dumps(result, ensure_ascii=True, indent=2)\n",
  "@mcp.tool()\ndef get_directions(start_location: str, end_location: str) -> str:\n    \"\"\"\n    Provides directions from a start location to an end location.\n    \n    Args:\n            start_location: str, The starting point for directions.\n            end_location: str, The destination point for directions.\n    \n    Returns:\n            json\n    \"\"\"\n\n    try:\n        import random\n\n        directions = [\n            \"Head north on Main St.\",\n            \"Turn right onto 5th Ave.\",\n            \"Continue straight to stay on Broadway.\",\n            \"Take the exit toward Downtown.\",\n            \"Merge onto I-95 N.\",\n            \"Turn left onto Elm St.\",\n            \"Slight right onto Park Ave.\",\n            \"At the roundabout, take the 2nd exit onto Maple Rd.\",\n            \"Continue onto Oak St.\",\n            \"Your destination will be on the right.\"\n        ]\n\n        random.seed(331)\n        route = []\n        for _ in range(random.randint(5, 8)):\n            step = random.choice(directions)\n            route.append(step)\n\n        result = {\n            \"data\": route\n        }\n    except Exception as e:\n        result = {\n            \"data\": []\n        }\n    finally:\n        import json\n        return json.dumps(result, ensure_ascii=True, indent=2)\n",
  "@mcp.tool()\ndef find_parking_nearby(location: str) -> str:\n    \"\"\"\n    Finds parking options near a specified location.\n    \n    Args:\n            location: str, The location to search for parking.\n    \n    Returns:\n            json\n    \"\"\"\n\n    try:\n        import random\n\n        parking_options = [\n            \"Lot A - 123 Main St.\",\n            \"Garage B - 456 Elm St.\",\n            \"Street Parking - 789 Oak St.\",\n            \"Lot C - 101 Maple Ave.\",\n            \"Garage D - 202 Pine St.\"\n        ]\n\n        random.seed(331)\n        available_parking = []\n        for _ in range(random.randint(2, 4)):\n            parking = random.choice(parking_options)\n            available_parking.append({\n                \"location\": parking,\n                \"availability\": random.choice([\"Available\", \"Full\"]),\n                \"price_per_hour\": random.randint(5, 20)\n            })\n\n        result = {\n            \"data\": available_parking\n        }\n    except Exception as e:\n        result = {\n            \"data\": []\n        }\n    finally:\n        import json\n        return json.dumps(result, ensure_ascii=True, indent=2)\n",
  "@mcp.tool()\ndef get_travel_time(start_location: str, end_location: str, mode_of_transport: str) -> str:\n    \"\"\"\n    Estimates travel time between two locations using a specified mode of transport.\n    \n    Args:\n            start_location: str, The starting point for travel.\n            end_location: str, The destination point for travel.\n            mode_of_transport: str, The mode of transport (e.g., 'driving', 'walking', 'bicycling', 'transit').\n    \n    Returns:\n            json\n    \"\"\"\n\n    try:\n        import random\n\n        travel_times = {\n            \"driving\": random.randint(10, 60),\n            \"walking\": random.randint(30, 120),\n            \"bicycling\": random.randint(15, 45),\n            \"transit\": random.randint(20, 90)\n        }\n\n        time = travel_times.get(mode_of_transport, \"Unknown\")\n\n        result = {\n            \"data\": {\n                \"mode_of_transport\": mode_of_transport,\n                \"estimated_time_minutes\": time\n            }\n        }\n    except Exception as e:\n        result = {\n            \"data\": {\n                \"mode_of_transport\": mode_of_transport,\n                \"estimated_time_minutes\": \"Unknown\"\n            }\n        }\n    finally:\n        import json\n        return json.dumps(result, ensure_ascii=True, indent=2)\n",
  "@mcp.tool()\ndef get_local_events(location: str, date: str) -> str:\n    \"\"\"\n    Retrieves a list of local events happening at a specified location on a given date.\n    \n    Args:\n            location: str, The location to search for events.\n            date: str, The date to search for events (format: YYYY-MM-DD).\n    \n    Returns:\n            json\n    \"\"\"\n\n    try:\n        import random\n\n        events = [\n            \"Music Festival at Central Park\",\n            \"Art Exhibition at the Modern Art Museum\",\n            \"Food Truck Rally at Downtown Plaza\",\n            \"Outdoor Movie Night at Riverside Park\",\n            \"Farmers Market at City Square\",\n            \"Tech Conference at Convention Center\",\n            \"Charity Run at Greenway Trail\",\n            \"Book Fair at Public Library\",\n            \"Craft Fair at Community Center\",\n            \"Wine Tasting at Vineyard\"\n        ]\n\n        random.seed(331)\n        local_events = []\n        for _ in range(random.randint(2, 4)):\n            event = random.choice(events)\n            local_events.append({\n                \"event\": event,\n                \"date\": date,\n                \"location\": location\n            })\n\n        result = {\n            \"data\": local_events\n        }\n    except Exception as e:\n        result = {\n            \"data\": []\n        }\n    finally:\n        import json\n        return json.dumps(result, ensure_ascii=True, indent=2)\n"
]